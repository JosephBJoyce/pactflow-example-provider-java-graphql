package com.example.springboot;

// --- Pact Provider JUnit support ---
// These imports enable Pact provider verification tests.
// Instead of mocking the provider, we now verify the REAL provider
// against contracts that were generated by consumers.
import au.com.dius.pact.provider.junitsupport.*;
import au.com.dius.pact.provider.junitsupport.loader.*;
import au.com.dius.pact.provider.junit5.HttpTestTarget;
import au.com.dius.pact.provider.junit5.PactVerificationContext;
import au.com.dius.pact.provider.junit5.PactVerificationInvocationContextProvider;

import java.io.IOException;

// --- JUnit 5 + Spring Boot test support ---
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.TestTemplate;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit.jupiter.SpringExtension;


// This tells JUnit to run the test with Spring support,
// so we get dependency injection and a real application context.
@ExtendWith(SpringExtension.class)

// This starts the full Spring Boot app for testing.
// DEFINED_PORT means the app runs on its configured port (here: 8080),
// instead of a random port — useful for Pact verification targeting.
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)

// This must match the provider name used in the consumer pact test.
// Pact uses this name to match contracts to this provider.
@Provider("pactflow-example-provider-java-graphql")

// This tells Pact where to load contracts from — in this case PactFlow / Pact Broker.
// Key demo points to mention:
// - Contracts are pulled dynamically
// - We verify against all relevant consumer contracts automatically
// - Branch-aware + pending pact support reduces deployment risk
@PactBroker(
  scheme = "https",
  host = "${PACT_BROKER_HOST}",                 // broker host from env/config
  providerBranch = "${GIT_BRANCH}",             // enables branch-based contract selection
  enablePendingPacts = "true",                  // allows safe rollout of new contracts
  authentication = @PactBrokerAuth(
    token = "${PACT_BROKER_TOKEN}"              // secure token-based auth
  )
)
class ProductsPactTest {

  // We inject the real repository so we can prepare test data.
  // Provider verification tests often need to seed known state.
  @Autowired
  ProductRepository repository;


  // This runs before each interaction verification.
  // Here we tell Pact where the running provider can be reached.
  @BeforeEach
  public void setupTestTarget(PactVerificationContext context) {

    // We point Pact at the REAL running service endpoint.
    // Pact will replay each contract request against this target.
    context.setTarget(new HttpTestTarget("localhost", 8080));
  }


  // This is a special JUnit 5 template test.
  // Pact injects each interaction from the contract as a separate test invocation.
  // So if there are 5 contract interactions, this runs 5 times.
  @TestTemplate
  @ExtendWith(PactVerificationInvocationContextProvider.class)
  public void pactVerificationTestTemplate(PactVerificationContext context) {

    // This line triggers the actual verification:
    // Pact sends the expected request to the provider
    // and compares the real response to the contract.
    context.verifyInteraction();
  }


  // Provider State Setup
  // This method is executed when an interaction requires this state.
  // The string must EXACTLY match the `.given(...)` value from the consumer pact.
  // This is how consumer expectations map to provider test setup.
  @State("a product with ID 10 exists")
  public void setupProductX010000021() throws IOException {

    // Demo talking point:
    // Provider states are how we prepare data and environment conditions
    // so the provider can satisfy the contract interaction.
    System.out.println("a product with ID 10 exists");

    // Seed the database with known data required by the contract.
    // This ensures deterministic, repeatable verification.
    repository.save(new Product(10L, "test", "product description", "1.0.0"));
  }
}
